{
    "contents" : "\n\n#calculate net benefit for a fitted risk or by fitting a risk model if formula is specified\ncalculate.nb <- function(y, d, rH, formula, data, family, formula.ind, casecontrol.rho){\n  #predictor y,  estimated risk\n  #disease indicator d\n  #vector of high risk thresholds rH\n\n  if(formula.ind){\n\n    #cohort data, no correction for population level outcome rate\n    if(is.null(casecontrol.rho)){\n       myglm <- do.call(glm, list(\"formula\" = formula, \"data\" = data, \"family\" = family ))\n       y <- fitted(myglm)\n    }else{\n      #offset by the relative observed outcome prevalence and the provided population rho\n      obs.rho = mean(d)\n      offset = - log((casecontrol.rho)/ (1-casecontrol.rho)) + log((obs.rho)/(1-obs.rho))\n      myglm <- do.call(glm, list(\"formula\" = formula, \"data\" = data, \"family\" = family, \"offset\" = rep(offset, nrow(data)) ))\n      y = predict(myglm, type = \"link\") - offset\n      y <- exp(y)/(1+exp(y))\n    }\n\n  }\n\n  N = length(y)\n\n  #denominator for tpf\n  tpf.den <- sum(d ==1)\n\n  #true positive fraction Pr(risk(X) > rH | D = 1)\n  tpf <- sum.I(rH, \"<\", y[d==1])/tpf.den\n\n  #false positive fraction Pr(risk(X) > rH | D = 0 )\n  fpf <- sum.I(rH, \"<\", y[d==0])/ (N - tpf.den)\n\n  #disease prevalence\nif(is.null(casecontrol.rho)){\n    rho = mean(d ==1)\n    prob.high.risk <- sum.I(rH, \"<\", y)/length(y)\n\n  }else{\n    rho = casecontrol.rho\n    prob.high.risk <- rho*sum.I(rH, \"<\", y[d==1])/length(y[d==1]) + (1-rho)*sum.I(rH, \"<\", y[d==0])/length(y[d==0])\n  }\n\n\n  #net benefit\n  nb = tpf*rho - (rH/(1-rH))*(1-rho)*fpf\n\n  #standardized net benefit\n  snb = nb/rho\n\n  #detection probability (for impact plots)\n  dp <- tpf*rho\n\n  out  = data.frame(\"threshold\" = rH,\n                    \"FPR\" = fpf , \"TPR\" = tpf,\n                    \"NB\" = nb, \"sNB\" = snb,\n                    \"rho\" = rho, \"prob.high.risk\" = prob.high.risk,\n                    \"DP\" = dp)\n\n # AUC   = sum(sort(tpf, decreasing = FALSE)*(sort(fpf, decreasing = FALSE)-c(sort(fpf, decreasing = FALSE)[-1],0)))\n\n\n}\n\n\n\nadd.ci.columns <- function(x){\n  n.out = nrow(x)\n\n  x$FPR_lower <- NA; x$FPR_upper <- NA\n  x$TPR_lower <-NA; x$TPR_upper <- NA\n  x$NB_lower <-NA; x$NB_upper <- NA\n  x$sNB_lower <-NA; x$sNB_upper <- NA\n  x$rho_lower <- NA; x$rho_upper <- NA\n  x$prob.high.risk_lower = NA; x$prob.high.risk_upper =NA\n  x$DP_lower = NA; x$DP_upper =NA\n  x\n}\n\n\nVTM <- function(vc, dm)\n{\n  matrix(vc, ncol = length(vc), nrow = dm, byrow = T)\n}\n\n\n#this function is magic!\n#for each element of yy it gives the count of how many Yi fall <, >, <=, or >= to it\n#output is a vector of length yy.\nsum.I<-function(yy,FUN,Yi,Vi=NULL){\n\n  if (FUN==\"<\"|FUN==\">=\") { yy <- -yy; Yi <- -Yi}\n\n  pos <- rank(c(yy,Yi),ties.method='f')[1:length(yy)]-rank(yy,ties.method='f')\n\n  if (substring(FUN,2,2)==\"=\") pos <- length(Yi)-pos\n\n  if (!is.null(Vi)) {\n\n    if(substring(FUN,2,2)==\"=\") tmpind <- order(-Yi) else  tmpind <- order(Yi)\n\n    Vi <- apply(as.matrix(Vi)[tmpind,,drop=F],2,cumsum)\n\n    return(rbind(0,Vi)[pos+1,])\n\n  } else return(pos)\n}\n\n\ncostbenefit_to_threshold <- function(CB){\n  CB/(1+CB)\n}\n\nthreshold_to_costbenefit <- function(rh){\n  rh/(1-rh)\n}\n",
    "created" : 1452639522551.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2730048431",
    "id" : "98DE885A",
    "lastKnownWriteTime" : 1452653146,
    "path" : "~/DecisionCurve-All/DecisionCurve/R/subroutines.R",
    "project_path" : "R/subroutines.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}