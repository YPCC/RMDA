{
    "contents" : "#' Calculate cross-validated decision curves\n#'\n#' This is a wrapper for 'decision_curve' that computes k-fold cross-validated estimates of sensitivity, specificity, and net benefit so that cross-validated net benefit curves can be plotted.\n#'\n#' @param formula an object of class 'formula' of the form outcome ~ predictors, giving the prediction model to be fitted using glm.\n#' @param data data.frame containing outcome and predictors. Missing data on any of the predictors will cause the entire observation to be removed.\n#' @param family a description of the error distribution and link function to pass to 'glm' used for model fitting. Defaults to binomial(link = \"logit\") for logistic regression.\n#' @param thresholds Numeric vector of high risk thresholds to use when plotting and calculating net benefit values.\n#' @param folds Number of folds for k-fold cross-validation.\n#' @param study.design Either 'cohort' (default) or 'case-control' describing the study design used to obtain data. See details for more information.\n#' @param population.prevalence  Outcome prevalence rate in the population used to calculate decision curves when study.design = 'case-control'.\n#' @return List with components\n#' \\itemize{\n#'   \\item derived.data: A data frame in long form showing the following for each predictor and each 'threshold', 'FPF':false positive fraction, 'TPF': true positive fraction, 'NB': net benefit, 'sNB': standardized net benefit, 'rho': outcome prevalence, 'predictor': name of predictor, 'xx_lower', 'xx_upper': the lower and upper confidence bands for TPF, FPF, rho, NB and sNB.\n#'   \\item standardized: Whether standardized net benefit or net benefit is returned.\n#'   \\item call: matched function call.\n#' }\n#'\n#' @seealso \\code{\\link{summary.decision_curve}}, \\code{\\link{decision_curve}},  \\code{\\link{Add_CostBenefit_Axis}}\n#' @examples\n#'\n#' #todo\n#'\n#' @importFrom caret createFolds\n#' @export\n\ncv_decision_curve <- function(formula,\n                           data,\n                           family = binomial(link = \"logit\"),\n                           thresholds = seq(0, 1, by = .01),\n                           folds = 5,\n                           study.design = c(\"cohort\", \"case-control\"),\n                           population.prevalence){\n  call <- match.call()\n\n  stopifnot(is.numeric(folds))\n  stopifnot(folds >= 2)\n\n  #check vars are in data\n  if(any( names.check <- !is.element(all.vars(formula), names(data)))) stop(paste(\"variable(s)\", paste( all.vars(formula)[names.check], collapse = \", \") , \"not found in 'data'\"))\n\n  study.design <- match.arg(study.design)\n\n  #throw out missing data\n  data <- data[,all.vars(formula)]\n  #complete case indicator\n  cc.ind <- complete.cases(data)\n\n  if(sum(cc.ind) < nrow(data)) warning(paste(sum(1-cc.ind), \"observation(s) with missing data removed\"))\n  data <- data[cc.ind,]\n\n  #retreive outcome\n  outcome <- data[[all.vars(formula[[2]])]];\n  if(length(unique(outcome)) != 2) stop(\"outcome variable is not binary (it does not take two unique values).\")\n  stopifnot(is.numeric(outcome))\n  if(min(outcome) != 0 | max(outcome) != 1) stop(\"outcome variable must be binary taking on values 0 for control and 1 for case.\")\n  ####################\n  ## done with checks\n  ####################\n\n  #create cross-validation folds using caret's 'createFolds'\n  myfolds.ind <- createFolds(y = outcome, k = folds)\n  #check to make sure there are cases and controls in each fold\n  lapply(myfolds.ind, FUN = function(x){ if(length(table(outcome[x])) < 2) stop(\"Reduce number of folds requested: there are not enough cases to allocate across all folds\")})\n  #make sure there are at least 5 cases per fold.\n  lapply(myfolds.ind, FUN = function(x){ if(min(table(outcome[x]))<5) stop(\"Reduce number of folds requested: there are not enough cases to allocate at least 5 cases into each fold.\")})\n\n  #now call `decision_curve` n = folds times and collect the results\n  #call it once to allocate a spot for the results\n  out <- list()\n  out$derived.data <- decision_curve(formula = formula,\n                        data = data,\n                        fitted.risk = FALSE,\n                        thresholds = thresholds,\n                        confidence.intervals = \"none\",\n                        study.design = study.design,\n                        population.prevalence = population.prevalence)$derived.data\n  out$derived.data[, 2:8] <- 0\n\n  for(kk in 1:folds){\n\n    #fit the model on -kk\n    #cohort\n    if(study.design == \"cohort\"){\n      myglm <- do.call(glm, list(\"formula\" = formula, \"data\" = data[-myfolds.ind[[kk]], ], \"family\" = family ))\n    }else{\n      #case.control\n      #offset by the relative observed outcome prevalence and the provided population rho\n      obs.rho = mean(outcome)\n      offset = log((population.prevalence)/ (1-(population.prevalence)))- log((obs.rho)/(1-obs.rho))\n      myglm <- do.call(glm, list(\"formula\" = formula, \"data\" = data[-myfold.ind[[kk]], ], \"family\" = family, \"offset\" = rep(offset, nrow(data)) ))\n\n    }\n\n    #predict on fold kk\n    y <- predict(myglm, newdata = data[myfolds.ind[[kk]], ], type = \"response\")\n\n    dat.cv <- data.frame(\"outcome\" = outcome[myfolds.ind[[kk]]], \"risk.hat\" = y)\n\n    #add measures for each fold to the first 8 columns, bc these are the\n    #the only numeric estimates.\n    #we divide by number of folds later\n    out$derived.data[,2:8] <- out$derived.data[,2:8] +\n                             decision_curve(formula = outcome~risk.hat,\n                             data = dat.cv,\n                             family = family,\n                             fitted.risk = TRUE,\n                             thresholds = thresholds,\n                             confidence.intervals = \"none\",\n                             study.design = study.design,\n                             population.prevalence = population.prevalence)$derived.data[,2:8]\n  }\n  #take the mean across folds as estimates\n  out$derived.data[,2:8] <- out$derived.data[,2:8]/folds\n\n\n  #return list of elements\n  out$call <- call\n  out$folds <- folds\n  out$confidence.intervals <- 'none'\n\n  class(out) = \"decision_curve\"\n  invisible(out)\n\n}\n\n\n",
    "created" : 1452625840555.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1361937904",
    "id" : "692940DA",
    "lastKnownWriteTime" : 1452636959,
    "path" : "~/DecisionCurve-All/DecisionCurve/R/cv_decision_curve.R",
    "project_path" : "R/cv_decision_curve.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}