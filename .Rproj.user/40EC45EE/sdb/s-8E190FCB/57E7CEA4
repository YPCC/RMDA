{
    "collab_server" : "",
    "contents" : "#' Calculate cross-validated decision curves\n#'\n#' This is a wrapper for 'decision_curve' that computes k-fold cross-validated estimates of sensitivity, specificity, and net benefit so that cross-validated net benefit curves can be plotted.\n#'\n#' @param formula an object of class 'formula' of the form outcome ~ predictors, giving the prediction model to be fitted using glm. The outcome must be a binary variable that equals '1' for cases and '0' for controls.\n#' @param data data.frame containing outcome and predictors. Missing data on any of the predictors will cause the entire observation to be removed.\n#' @param family a description of the error distribution and link function to pass to 'glm\" used for model fitting. Defaults to binomial(link = \"logit\") for logistic regression.\n#' @param thresholds Numeric vector of high risk thresholds to use when plotting and calculating net benefit values.\n#' @param folds Number of folds for k-fold cross-validation.\n#' @param study.design Either 'cohort' (default) or 'case-control' describing the study design used to obtain data. See details for more information.\n#' @param population.prevalence  Outcome prevalence rate in the population used to calculate decision curves when study.design = 'case-control'.\n#' @param policy Either 'opt-in' (default) or 'opt-out', describing the type of policy for which to report the net benefit. A policy is 'opt-in' when the standard-of-care for a population is to assign a particular 'treatment' to no one. Clinicians then use a risk model to categorize patients as 'high-risk', with the recommendation to treat high-risk patients with some intervention. Alternatively, an 'opt-out' policy is applicable to contexts where the standard-of-care is to recommend a treatment to an entire patient population. The potential use of a risk model in this setting is to identify patients who are 'low-risk' and recommend that those patients 'opt-out' of treatment.\n#' @return List with components\n#' \\itemize{\n#'   \\item derived.data: derived.data: A data frame in long form showing the following for each predictor and each 'threshold', 'FPR':false positive rate, 'TPR': true positive rate, 'NB': net benefit, 'sNB': standardized net benefit, 'rho': outcome prevalence, 'prob.high.risk': percent of the population considered high risk. 'DP': detection probability = TPR*rho, 'model': name of prediction model or 'all' or 'none', and cost.benefit.ratio's.\n#'   \\item folds: number of folds used for cross-validation.\n#'   \\item call: matched function call.\n#' }\n#'\n#' @seealso \\code{\\link{summary.decision_curve}}, \\code{\\link{decision_curve}},  \\code{\\link{Add_CostBenefit_Axis}}\n#' @examples\n#'\n#' full.model_cv <- cv_decision_curve(Cancer~Age + Female + Smokes + Marker1 + Marker2,\n#'                                   data = dcaData,\n#'                                   folds = 5,\n#'                                   thresholds = seq(0, .4, by = .01))\n#'\n#'full.model_apparent <- decision_curve(Cancer~Age + Female + Smokes + Marker1 + Marker2,\n#'                                      data = dcaData,\n#'                                      thresholds = seq(0, .4, by = .01),\n#'                                      confidence.intervals = 'none')\n#'\n#'plot_decision_curve( list(full.model_apparent, full.model_cv),\n#'                     curve.names = c('Apparent curve', 'Cross-validated curve'),\n#'                     col = c('red', 'blue'),\n#'                     lty = c(2,1),\n#'                     lwd = c(3,2, 2, 1),\n#'                     legend.position = 'bottomright')\n#'\n#' @importFrom caret createFolds\n#' @export\n\ncv_decision_curve <- function(formula,\n                           data,\n                           family = binomial(link = 'logit'),\n                           thresholds = seq(0, 1, by = .01),\n                           folds = 5,\n                           study.design = c('cohort', \"case-control\"),\n                           population.prevalence,\n                           policy = c(\"opt-in\", \"opt-out\")){\n  call <- match.call()\n\n  stopifnot(is.numeric(folds))\n  stopifnot(folds >= 2)\n\n  #check vars are in data\n  if(any( names.check <- !is.element(all.vars(formula), names(data)))) stop(paste(\"variable(s)\", paste( all.vars(formula)[names.check], collapse = \", \") , \"not found in 'data'\"))\n\n  study.design <- match.arg(study.design)\n  policy = match.arg(policy)\n  #throw out missing data\n  data <- data[,all.vars(formula)]\n  #complete case indicator\n  cc.ind <- complete.cases(data)\n\n  if(sum(cc.ind) < nrow(data)) warning(paste(sum(1-cc.ind), \"observation(s) with missing data removed\"))\n  data <- data[cc.ind,]\n\n  #retreive outcome\n  outcome <- data[[all.vars(formula[[2]])]];\n  if(length(unique(outcome)) != 2) stop(\"outcome variable is not binary (it does not take two unique values).\")\n  stopifnot(is.numeric(outcome))\n  if(min(outcome) != 0 | max(outcome) != 1) stop(\"outcome variable must be binary taking on values 0 for control and 1 for case.\")\n  ####################\n  ## done with checks\n  ####################\n\n  #create cross-validation folds using caret's 'createFolds'\n  myfolds.ind <- createFolds(y = as.factor(outcome), k = folds)\n  #check to make sure there are cases and controls in each fold\n  lapply(myfolds.ind, FUN = function(x){ if(length(table(outcome[x])) < 2) stop(\"Reduce number of folds requested: there are not enough cases to allocate across all folds\")})\n  #make sure there are at least 5 cases per fold.\n  lapply(myfolds.ind, FUN = function(x){ if(min(table(outcome[x]))<5) stop(\"Reduce number of folds requested: there are not enough cases to allocate at least 5 cases into each fold.\")})\n\n  #now call `decision_curve` n = folds times and collect the results\n  #call it once to allocate a spot for the results\n  out <- list()\n  out$derived.data <- decision_curve(formula = formula,\n                        data = data,\n                        fitted.risk = FALSE,\n                        thresholds = thresholds,\n                        confidence.intervals = \"none\",\n                        study.design = study.design,\n                        population.prevalence = population.prevalence,\n                        policy =policy)$derived.data\n\n  out$derived.data[, 2:12] <- 0\n\n  for(kk in 1:folds){\n\n    #fit the model on -kk\n    #cohort\n    if(study.design == \"cohort\"){\n      myglm <- do.call(glm, list(\"formula\" = formula, \"data\" = data[-myfolds.ind[[kk]], ], \"family\" = family ))\n      offset = 0\n      }else{\n      #case.control\n      #offset by the relative observed outcome prevalence and the provided population rho\n      obs.rho = mean(outcome)\n      offset = - log((population.prevalence)/ (1-(population.prevalence))) + log((obs.rho)/(1-obs.rho))\n      myglm <- do.call(glm, list(\"formula\" = formula, \"data\" = data[-myfolds.ind[[kk]], ], \"family\" = family, \"offset\" = rep(offset, nrow(data[-myfolds.ind[[kk]], ])) ))\n\n    }\n\n    #predict on fold kk\n    y <- predict(myglm, newdata = data[myfolds.ind[[kk]], ], type = \"link\") - offset\n    y <- exp(y)/(1+exp(y))\n\n    dat.cv <- data.frame(\"outcome\" = outcome[myfolds.ind[[kk]]], \"risk.hat\" = y)\n\n    #add measures for each fold to the first 8 columns, bc these are the\n    #the only numeric estimates.\n    #we divide by number of folds later\n    out$derived.data[,2:12] <- out$derived.data[,2:12] +\n                             decision_curve(formula = outcome~risk.hat,\n                             data = dat.cv,\n                             family = family,\n                             fitted.risk = TRUE,\n                             thresholds = thresholds,\n                             confidence.intervals = \"none\",\n                             study.design = study.design,\n                             population.prevalence = population.prevalence,\n                             policy = policy)$derived.data[,2:12]\n  }\n  #take the mean across folds as estimates\n\n  out$derived.data[,2:12] <- out$derived.data[,2:12]/folds\n\n\n  #return list of elements\n  out$call <- call\n  out$folds <- folds\n  out$policy = policy\n  out$confidence.intervals <- 'none'\n\n  class(out) = \"decision_curve\"\n  invisible(out)\n\n}\n\n\n",
    "created" : 1524255162456.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4272898065",
    "id" : "57E7CEA4",
    "lastKnownWriteTime" : 1521605236,
    "last_content_update" : 1521605236,
    "path" : "~/Documents/GitHub/rmda/R/cv_decision_curve.R",
    "project_path" : "R/cv_decision_curve.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}